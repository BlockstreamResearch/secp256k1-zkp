#!/usr/bin/env python3

import sys
import json
import textwrap

max_participants = 0

if len(sys.argv) < 2:
    print(
        "This script converts BIP FROST test vectors in a given directory to a C file that can be used in the test framework."
    )
    print("Usage: %s <dir>" % sys.argv[0])
    sys.exit(1)


def hexstr_to_intarray(str):
    return ", ".join([f"0x{b:02X}" for b in bytes.fromhex(str)])


def create_init(name):
    return """
static const struct frost_%s_vector frost_%s_vector = {
""" % (
        name,
        name,
    )


def init_array(key):
    return textwrap.indent("{ %s },\n" % hexstr_to_intarray(data[key]), 4 * " ")


def init_arrays(key):
    s = textwrap.indent("{\n", 4 * " ")
    s += textwrap.indent(
        ",\n".join(["{ %s }" % hexstr_to_intarray(x) for x in data[key]]), 8 * " "
    )
    s += textwrap.indent("\n},\n", 4 * " ")
    return s


def init_nested_arrays(array):
    return "{ %s }" % ", ".join(["{ %s }" % hexstr_to_intarray(x) for x in array])


def init_indices(array):
    return " %d, { %s }" % (
        len(array),
        ", ".join(map(str, array)) if len(array) > 0 else "0",
    )


def init_is_xonly(case):
    if len(case.get("tweak_indices", [])) > 0:
        return ", ".join("1" if x else "0" for x in case["is_xonly"])
    return "0"


def init_optional_expected(case):
    return hexstr_to_intarray(case["expected"]) if "expected" in case else "0"


def init_cases(cases, f):
    s = textwrap.indent("{\n", 4 * " ")
    for (i, case) in enumerate(cases):
        s += textwrap.indent("%s\n" % f(case), 8 * " ")
    s += textwrap.indent("},\n", 4 * " ")
    return s


def finish_init():
    return "};\n"


s = (
    """/**
 * Automatically generated by %s.
 *
 * The test vectors for the FROST implementation.
 */
"""
    % sys.argv[0]
)

s += """
enum FROST_ERROR {
    FROST_PUBKEY,
    FROST_PUBSHARE,
    FROST_TWEAK,
    FROST_PUBNONCE,
    FROST_AGGNONCE,
    FROST_SECNONCE,
    FROST_SIG,
    FROST_SIG_VERIFY,
    FROST_OTHER
};
"""

# key gen vectors
with open(sys.argv[1] + "/keygen_vectors.json") as f:
    data = json.load(f)

    num_valid_cases = len(data["valid_test_cases"])
    num_pubshare_fail_cases = len(data["pubshare_correctness_fail_test_cases"])
    num_group_pubkey_fail_cases = len(data["group_pubkey_correctness_fail_test_cases"])

    all_cases = (
        data["valid_test_cases"]
        + data["pubshare_correctness_fail_test_cases"]
        + data["group_pubkey_correctness_fail_test_cases"]
    )
    max_participants = max(
        len(test_case["participant_identifiers"]) for test_case in all_cases
    )

    # Add structures for valid and error cases
    s += """
struct frost_key_gen_valid_test_case {
    size_t max_participants;
    size_t min_participants;
    unsigned char group_public_key[33];
    size_t participant_identifiers_len;
    size_t participant_identifiers[%d];
    unsigned char participant_pubshares[%d][33];
    unsigned char participant_secshares[%d][32];
};
""" % (
        max_participants,
        max_participants,
        max_participants,
    )
    s += """
struct frost_key_gen_pubshare_fail_test_case {
    size_t max_participants;
    size_t min_participants;
    unsigned char group_public_key[33];
    size_t participant_identifiers_len;
    size_t participant_identifiers[%d];
    unsigned char participant_pubshares[%d][33];
    unsigned char participant_secshares[%d][32];
    enum FROST_ERROR error;
};
""" % (
        max_participants,
        max_participants,
        max_participants,
    )
    s += """
struct frost_key_gen_pubkey_fail_test_case {
    size_t max_participants;
    size_t min_participants;
    unsigned char group_public_key[33];
    size_t participant_identifiers_len;
    size_t participant_identifiers[%d];
    unsigned char participant_pubshares[%d][33];
    unsigned char participant_secshares[%d][32];
    enum FROST_ERROR error;
};
""" % (
        max_participants,
        max_participants,
        max_participants,
    )

    # Add structure for entire vector

    s += """
struct frost_key_gen_vector {
    struct frost_key_gen_valid_test_case valid_cases[%d];
    struct frost_key_gen_pubshare_fail_test_case pubshare_fail_cases[%d];
    struct frost_key_gen_pubkey_fail_test_case pubkey_fail_cases[%d];
};
""" % (
        num_valid_cases,
        num_pubshare_fail_cases,
        num_group_pubkey_fail_cases,
    )

    s += create_init("key_gen")

    #  Add valid cases to the vector
    s += init_cases(
        data["valid_test_cases"],
        lambda case: "{ %d, %d, { %s }, %s, %s, %s },"
        % (
            case["max_participants"],
            case["min_participants"],
            hexstr_to_intarray(case["group_public_key"]),
            init_indices(case["participant_identifiers"]),
            init_nested_arrays(case["participant_pubshares"]),
            init_nested_arrays(case["participant_secshares"]),
        ),
    )

    def comment_to_error(case):
        comment = case["comment"]
        if "public key" in comment.lower():
            return "FROST_PUBKEY"
        elif "pubshare" in comment.lower():
            return "FROST_PUBSHARE"
        else:
            sys.exit("Unknown error")

    for cases in ("pubshare_correctness_fail_test_cases", "group_pubkey_correctness_fail_test_cases"):
        s += init_cases(
            data[cases],
            lambda case: "{ %d, %d, { %s }, %s, %s, %s, %s },"
            % (
                case["max_participants"],
                case["min_participants"],
                hexstr_to_intarray(case["group_public_key"]),
                init_indices(case["participant_identifiers"]),
                init_nested_arrays(case["participant_pubshares"]),
                init_nested_arrays(case["participant_secshares"]),
                comment_to_error(case),
            ),
        )
    s += finish_init()
s += "enum { FROST_VECTORS_MAX_PARTICIPANTS = %d };" % max_participants
print(s)
