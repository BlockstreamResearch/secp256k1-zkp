/**********************************************************************
 * Copyright (c) 2023-2024 Zhe Pang and Sivaram Dhakshinamoorthy      *
 * Distributed under the MIT software license, see the accompanying   *
 * file COPYING or http://www.opensource.org/licenses/mit-license.php.*
 **********************************************************************/

#ifndef SECP256K1_MODULE_SCHNORR_ADAPTOR_TESTS_H
#define SECP256K1_MODULE_SCHNORR_ADAPTOR_TESTS_H

#include "../../../include/secp256k1_schnorrsig.h"
#include "../../../include/secp256k1_schnorr_adaptor.h"

/* Checks that a bit flip in the n_flip-th argument (that has n_bytes many
 * bytes) changes the hash function
 */
static void nonce_function_schnorr_adaptor_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes, size_t algolen) {
    unsigned char nonces[2][32];
    CHECK(nonce_function_schnorr_adaptor(nonces[0], args[0], args[1], args[2], args[3], args[4], algolen, args[5]) == 1);
    secp256k1_testrand_flip(args[n_flip], n_bytes);
    CHECK(nonce_function_schnorr_adaptor(nonces[1], args[0], args[1], args[2], args[3], args[4], algolen, args[5]) == 1);
    CHECK(secp256k1_memcmp_var(nonces[0], nonces[1], 32) != 0);
}

static void run_nonce_function_schnorr_adaptor_tests(void) {
    unsigned char tag[20] = "SchnorrAdaptor/nonce";
    unsigned char aux_tag[18] = "SchnorrAdaptor/aux";
    unsigned char algo[20] = "SchnorrAdaptor/nonce";
    size_t algolen = sizeof(algo);
    secp256k1_sha256 sha;
    secp256k1_sha256 sha_optimized;
    unsigned char nonce[32], nonce_z[32];
    unsigned char msg[32];
    unsigned char key[32];
    unsigned char adaptor[33];
    unsigned char pk[32];
    unsigned char aux_rand[32];
    unsigned char *args[6];
    int i;

    /* Check that hash initialized by
     * secp256k1_nonce_function_schnorr_adaptor_sha256_tagged has the expected
     * state. */
    secp256k1_sha256_initialize_tagged(&sha, tag, sizeof(tag));
    secp256k1_nonce_function_schnorr_adaptor_sha256_tagged(&sha_optimized);
    test_sha256_eq(&sha, &sha_optimized);

   /* Check that hash initialized by
    * secp256k1_nonce_function_schnorr_adaptor_sha256_tagged_aux has the expected
    * state. */
    secp256k1_sha256_initialize_tagged(&sha, aux_tag, sizeof(aux_tag));
    secp256k1_nonce_function_schnorr_adaptor_sha256_tagged_aux(&sha_optimized);
    test_sha256_eq(&sha, &sha_optimized);

    secp256k1_testrand256(msg);
    secp256k1_testrand256(key);
    /* The random function below may generate an invalid (serialized) adaptor
     * point, but for testing the nonce function, this invalid argument
     * is acceptable. */
    secp256k1_testrand_bytes_test(adaptor, sizeof(adaptor));
    secp256k1_testrand256(pk);
    secp256k1_testrand256(aux_rand);

    /* Check that a bitflip in an argument results in different nonces. */
    args[0] = msg;
    args[1] = key;
    args[2] = adaptor;
    args[3] = pk;
    args[4] = algo;
    args[5] = aux_rand;
    for (i = 0; i < COUNT; i++) {
        nonce_function_schnorr_adaptor_bitflip(args, 0, 32, algolen);
        nonce_function_schnorr_adaptor_bitflip(args, 1, 32, algolen);
        nonce_function_schnorr_adaptor_bitflip(args, 2, 33, algolen);
        nonce_function_schnorr_adaptor_bitflip(args, 3, 32, algolen);
        /* Flip algo special case "SchnorrAdaptor/nonce" */
        nonce_function_schnorr_adaptor_bitflip(args, 4, algolen, algolen);
        /* Flip algo again */
        nonce_function_schnorr_adaptor_bitflip(args, 4, algolen, algolen);
        nonce_function_schnorr_adaptor_bitflip(args, 5, 32, algolen);
    }

    /* NULL algo is disallowed */
    CHECK(nonce_function_schnorr_adaptor(nonce, msg, key, adaptor, pk, NULL, 0, NULL) == 0);
    CHECK(nonce_function_schnorr_adaptor(nonce, msg, key, adaptor, pk, algo, algolen, NULL) == 1);
    /* Other algo is fine */
    secp256k1_testrand_bytes_test(algo, algolen);
    CHECK(nonce_function_schnorr_adaptor(nonce, msg, key, adaptor, pk, algo, algolen, NULL) == 1);

    /* Different algolen gives different nonce */
    for (i = 0; i < COUNT; i++) {
        unsigned char nonce2[32];
        uint32_t offset = secp256k1_testrand_int(algolen - 1);
        size_t algolen_tmp = (algolen + offset) % algolen;

        CHECK(nonce_function_schnorr_adaptor(nonce2, msg, key, adaptor, pk, algo, algolen_tmp, NULL) == 1);
        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);
    }

    /* NULL aux_rand argument is allowed, and identical to passing all zero aux_rand. */
    memset(aux_rand, 0, 32);
    CHECK(nonce_function_schnorr_adaptor(nonce_z, msg, key, adaptor, pk, algo, algolen, &aux_rand) == 1);
    CHECK(nonce_function_schnorr_adaptor(nonce, msg, key, adaptor, pk, algo, algolen, NULL) == 1);
    CHECK(secp256k1_memcmp_var(nonce_z, nonce, 32) == 0);
}

static void test_schnorr_adaptor_api(void) {
    unsigned char sk[32];
    unsigned char msg[32];
    secp256k1_keypair keypair;
    secp256k1_keypair invalid_keypair = {{ 0 }};
    secp256k1_xonly_pubkey pk;
    secp256k1_xonly_pubkey zero_pk;
    unsigned char pre_sig[65];
    unsigned char invalid_pre_sig[65] = { 0 };
    unsigned char sig[64];
    unsigned char sec_adaptor[32];
    secp256k1_pubkey adaptor;
    secp256k1_pubkey invalid_adaptor = {{ 0 }};
    unsigned char extracted_sec_adaptor[32];
    secp256k1_pubkey extracted_adaptor;

    /* setup */
    secp256k1_testrand256(sk);
    secp256k1_testrand256(msg);
    secp256k1_testrand256(sec_adaptor);

    CHECK(secp256k1_keypair_create(CTX, &keypair, sk) == 1);
    CHECK(secp256k1_keypair_xonly_pub(CTX, &pk, NULL, &keypair) == 1);
    memset(&zero_pk, 0, sizeof(zero_pk));
    CHECK(secp256k1_ec_pubkey_create(CTX, &adaptor, sec_adaptor) == 1);

    /* main test body */
    CHECK(secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &keypair, &adaptor, NULL) == 1);
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_presign(CTX, NULL, msg, &keypair, &adaptor, NULL));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_presign(CTX, pre_sig, NULL, &keypair, &adaptor, NULL));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, NULL, &adaptor, NULL));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &keypair, NULL, NULL));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &invalid_keypair, &adaptor, NULL));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &keypair, &invalid_adaptor, NULL));
    CHECK_ILLEGAL(STATIC_CTX, secp256k1_schnorr_adaptor_presign(STATIC_CTX, pre_sig, msg, &keypair, &adaptor, NULL));

    CHECK(secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &keypair, &adaptor, NULL) == 1);
    CHECK(secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor, pre_sig, msg, &pk) == 1);
    CHECK(secp256k1_memcmp_var(&extracted_adaptor, &adaptor, sizeof(adaptor)) == 0);
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_extract(CTX, NULL, pre_sig, msg, &pk));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor, NULL, msg, &pk));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor, pre_sig, NULL, &pk));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor, pre_sig, msg, NULL));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor, pre_sig, msg, &zero_pk));

    CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig, pre_sig, sec_adaptor) == 1);
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_adapt(CTX, NULL, pre_sig, sec_adaptor));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_adapt(CTX, sig, NULL, sec_adaptor));
    /* invalid pre_sig[0] byte */
    CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig, invalid_pre_sig, sec_adaptor) == 0);
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_adapt(CTX, sig, pre_sig, NULL));

    CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig, pre_sig, sec_adaptor) == 1);
    CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor, pre_sig, sig) == 1);
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_extract_sec(CTX, NULL, pre_sig, sig));
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor, NULL, sig));
    /* invalid pre_sig[0] byte */
    CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor, invalid_pre_sig, sig) == 0);
    CHECK_ILLEGAL(CTX, secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor, pre_sig, NULL));
}

/* Helper function for schnorr_adaptor_vectors
 * Signs the message and checks that it's the same as expected_presig. */
static void test_schnorr_adaptor_spec_vectors_check_presigning(const unsigned char *sk, const unsigned char *pk_serialized, const unsigned char *aux_rand, const unsigned char *msg32, const unsigned char *adaptor_serialized, const unsigned char *expected_presig) {
    unsigned char pre_sig[65];
    secp256k1_keypair keypair;
    secp256k1_xonly_pubkey pk, pk_expected;
    secp256k1_pubkey adaptor, adaptor_extracted;
    CHECK(secp256k1_ec_pubkey_parse(CTX, &adaptor, adaptor_serialized, 33));

    CHECK(secp256k1_keypair_create(CTX, &keypair, sk));
    CHECK(secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg32, &keypair, &adaptor, aux_rand));
    CHECK(secp256k1_memcmp_var(pre_sig, expected_presig, 65) == 0);

    CHECK(secp256k1_xonly_pubkey_parse(CTX, &pk_expected, pk_serialized));
    CHECK(secp256k1_keypair_xonly_pub(CTX, &pk, NULL, &keypair));
    CHECK(secp256k1_memcmp_var(&pk, &pk_expected, sizeof(pk)) == 0);
    CHECK(secp256k1_schnorr_adaptor_extract(CTX, &adaptor_extracted, pre_sig, msg32, &pk));
    CHECK(secp256k1_ec_pubkey_cmp(CTX, &adaptor_extracted, &adaptor) == 0);
}

/* Helper function for schnorr_adaptor_vectors
 * Extracts the adaptor point and checks if it returns the same value as expected. */
static void test_schnorr_adaptor_spec_vectors_check_extract(const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *adaptor_serialized, const unsigned char *pre_sig, int extract_success, int extracted_val_correct) {
    secp256k1_xonly_pubkey pk;
    secp256k1_pubkey adaptor, adaptor_extracted;
    CHECK(secp256k1_xonly_pubkey_parse(CTX, &pk, pk_serialized));
    CHECK(secp256k1_ec_pubkey_parse(CTX, &adaptor, adaptor_serialized, 33));
    CHECK(extract_success == secp256k1_schnorr_adaptor_extract(CTX, &adaptor_extracted, pre_sig, msg32, &pk));
    if (extract_success) {
        CHECK(extracted_val_correct == (secp256k1_ec_pubkey_cmp(CTX, &adaptor_extracted, &adaptor) == 0));
    }
 }

/* Helper function for schnorr_adaptor_vectors
 * Adapts a Schnorr pre-signature in a BIP340 signature
 * and checks if it is [1] same as expected_sig64, and
 * [2] valid BIP340 signature. */
static void test_schnorr_adaptor_spec_vectors_check_adapt(const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *pre_sig, const unsigned char *secadaptor, const unsigned char *expected_sig, int expected) {
    unsigned char sig[64];
    secp256k1_xonly_pubkey pk;
    CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig, pre_sig, secadaptor));
    CHECK(secp256k1_memcmp_var(sig, expected_sig, 64) == 0);

    CHECK(secp256k1_xonly_pubkey_parse(CTX, &pk, pk_serialized));
    CHECK(expected == secp256k1_schnorrsig_verify(CTX, sig, msg32, 32, &pk));
}

/* Helper function for schnorr_adaptor_vectors
 * Extracts the secret adaptor from a pre-signature and a BIP340
  * signature and checks if it is the same as expected_secadaptor. */
static void test_schnorr_adaptor_spec_vectors_check_extract_sec(const unsigned char *pre_sig, const unsigned char *sig, const unsigned char *expected_secadaptor, int expected) {
    unsigned char sec_adaptor[32];

    CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, sec_adaptor, pre_sig, sig));
    CHECK(expected == (secp256k1_memcmp_var(sec_adaptor, expected_secadaptor, 32) == 0));
}

/* Test vectors according to Schnorr adaptor signature spec.
 * See https://github.com/ZhePang/Python_Specification_for_Schnorr_Adaptor */
static void test_schnorr_adaptor_spec_vectors(void) {
    {
        /* Presig: Test vector 0 */
        const unsigned char sk[32] = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
        };
        const unsigned char pk[32] = {
            0xF9, 0x30, 0x8A, 0x01, 0x92, 0x58, 0xC3, 0x10,
            0x49, 0x34, 0x4F, 0x85, 0xF8, 0x9D, 0x52, 0x29,
            0xB5, 0x31, 0xC8, 0x45, 0x83, 0x6F, 0x99, 0xB0,
            0x86, 0x01, 0xF1, 0x13, 0xBC, 0xE0, 0x36, 0xF9
        };
        unsigned char aux_rand[32] = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };
        const unsigned char msg[32] = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };
        const unsigned char adaptor[33] = {
            0x02, 0xC6, 0x04, 0x7F, 0x94, 0x41, 0xED, 0x7D,
            0x6D, 0x30, 0x45, 0x40, 0x6E, 0x95, 0xC0, 0x7C,
            0xD8, 0x5C, 0x77, 0x8E, 0x4B, 0x8C, 0xEF, 0x3C,
            0xA7, 0xAB, 0xAC, 0x09, 0xB9, 0x5C, 0x70, 0x9E,
            0xE5
        };
        const unsigned char pre_sig[65] = {
            0x03, 0x61, 0x79, 0xDB, 0xF3, 0xE1, 0x32, 0x07,
            0x85, 0x3F, 0x88, 0x0C, 0x7A, 0x7A, 0x85, 0xEC,
            0x67, 0x8B, 0xAD, 0x64, 0xB8, 0x97, 0xF1, 0x08,
            0xD4, 0x76, 0x43, 0x8A, 0xC4, 0xA9, 0x32, 0xEE,
            0x94, 0x97, 0xCC, 0x73, 0xB8, 0xC3, 0x51, 0xF1,
            0x89, 0xB9, 0xD4, 0xFD, 0xE8, 0x93, 0xE3, 0x82,
            0x0D, 0x4B, 0xFF, 0x7F, 0x49, 0xD4, 0xBE, 0x1F,
            0x8B, 0x02, 0xCB, 0x80, 0x8C, 0xD3, 0x19, 0x23,
            0xA0
        };
        test_schnorr_adaptor_spec_vectors_check_presigning(sk, pk, aux_rand, msg, adaptor, pre_sig);
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 1, 1);
    };
    {
        /* Presig: Test vector 1 */
        const unsigned char sk[32] = {
            0x0B, 0x43, 0x2B, 0x26, 0x77, 0x93, 0x73, 0x81,
            0xAE, 0xF0, 0x5B, 0xB0, 0x2A, 0x66, 0xEC, 0xD0,
            0x12, 0x77, 0x30, 0x62, 0xCF, 0x3F, 0xA2, 0x54,
            0x9E, 0x44, 0xF5, 0x8E, 0xD2, 0x40, 0x17, 0x10
        };
        const unsigned char pk[32] = {
            0x25, 0xD1, 0xDF, 0xF9, 0x51, 0x05, 0xF5, 0x25,
            0x3C, 0x40, 0x22, 0xF6, 0x28, 0xA9, 0x96, 0xAD,
            0x3A, 0x0D, 0x95, 0xFB, 0xF2, 0x1D, 0x46, 0x8A,
            0x1B, 0x33, 0xF8, 0xC1, 0x60, 0xD8, 0xF5, 0x17
        };
        const unsigned char aux_rand[32] = {
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
        };
        const unsigned char msg[32] = {
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
        };
        const unsigned char adaptor[33] = {
            0x03, 0x97, 0x72, 0x0B, 0x39, 0x10, 0x29, 0xF5,
            0x79, 0xF1, 0xF5, 0x71, 0x73, 0x35, 0x0B, 0x76,
            0xE4, 0xA7, 0xC3, 0xF4, 0x71, 0x53, 0xA5, 0x0E,
            0x46, 0xFA, 0x3A, 0x5F, 0x08, 0xBE, 0x66, 0xB1,
            0x4A
        };
        const unsigned char pre_sig[65] = {
            0x02, 0xC9, 0x74, 0xF5, 0x2A, 0xEC, 0xE9, 0x7C,
            0x75, 0xE4, 0x40, 0xA8, 0xD8, 0x67, 0x7F, 0xC5,
            0x10, 0x5D, 0x85, 0x12, 0x28, 0x7B, 0x9C, 0x03,
            0x04, 0xFA, 0x8D, 0x51, 0xF0, 0xBF, 0x48, 0x60,
            0xBA, 0xA5, 0x30, 0x46, 0xD2, 0x22, 0x1B, 0xB1,
            0x23, 0xBA, 0x04, 0x5F, 0xF5, 0xE5, 0xBD, 0x26,
            0xD8, 0x8D, 0x0B, 0xF0, 0xD6, 0x3B, 0x80, 0xE6,
            0x40, 0x59, 0x99, 0xC1, 0xD2, 0xB6, 0xFF, 0x00,
            0x71
        };
        test_schnorr_adaptor_spec_vectors_check_presigning(sk, pk, aux_rand, msg, adaptor, pre_sig);
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 1, 1);
    };
    {
        /* Presig: Test vector 2 */
        const unsigned char pk[32] = {
            0xD6, 0x9C, 0x35, 0x09, 0xBB, 0x99, 0xE4, 0x12,
            0xE6, 0x8B, 0x0F, 0xE8, 0x54, 0x4E, 0x72, 0x83,
            0x7D, 0xFA, 0x30, 0x74, 0x6D, 0x8B, 0xE2, 0xAA,
            0x65, 0x97, 0x5F, 0x29, 0xD2, 0x2D, 0xC7, 0xB9
        };
        const unsigned char msg[32] = {
            0x4D, 0xF3, 0xC3, 0xF6, 0x8F, 0xCC, 0x83, 0xB2,
            0x7E, 0x9D, 0x42, 0xC9, 0x04, 0x31, 0xA7, 0x24,
            0x99, 0xF1, 0x78, 0x75, 0xC8, 0x1A, 0x59, 0x9B,
            0x56, 0x6C, 0x98, 0x89, 0xB9, 0x69, 0x67, 0x03
        };
        const unsigned char adaptor[33] = {
            0x02, 0xA6, 0xB5, 0x94, 0xB3, 0x8F, 0xB3, 0xE7,
            0x7C, 0x6E, 0xDF, 0x78, 0x16, 0x1F, 0xAD, 0xE2,
            0x04, 0x1F, 0x4E, 0x09, 0xFD, 0x84, 0x97, 0xDB,
            0x77, 0x6E, 0x54, 0x6C, 0x41, 0x56, 0x7F, 0xEB,
            0x3C
        };
        const unsigned char pre_sig[65] = {
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x3B, 0x78, 0xCE, 0x56,
            0x3F, 0x89, 0xA0, 0xED, 0x94, 0x14, 0xF5, 0xAA,
            0x28, 0xAD, 0x0D, 0x96, 0xD6, 0x79, 0x5F, 0x9C,
            0x63, 0xB6, 0xAF, 0xB1, 0x54, 0x8A, 0xF6, 0x03,
            0xB3, 0xEB, 0x45, 0xC9, 0xF8, 0x20, 0x7D, 0xEE,
            0x10, 0x0F, 0x77, 0x28, 0xF9, 0xFA, 0x53, 0x1D,
            0xA1, 0xF5, 0xFF, 0x9F, 0x75, 0xB7, 0x16, 0x68,
            0x44
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 1, 1);
    };
    {
        /* Presig: Test vector 3 */
        const unsigned char pk[32] = {
            0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77, 0x50,
            0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF, 0x21,
            0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76, 0x87,
            0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A, 0x34
        };
        secp256k1_xonly_pubkey pk_parsed;
        /* No need to check adaptor_extract as parsing the pubkey already fails */
        CHECK(!secp256k1_xonly_pubkey_parse(CTX, &pk_parsed, pk));
    };
    {
        /* Presig: Test vector 4 */
        const unsigned char pk[32] = {
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F
        };
        secp256k1_xonly_pubkey pk_parsed;
        /* No need to check adaptor_extract as parsing the pubkey already fails */
        CHECK(!secp256k1_xonly_pubkey_parse(CTX, &pk_parsed, pk));
    };
    {
        /* Presig: Test vector 5 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char adaptor[33] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83
        };
        const unsigned char pre_sig[65] = {
            0x03, 0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,
            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,
            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,
            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,
            0x34, 0x79, 0x78, 0x3A, 0xCC, 0xAA, 0x0E, 0x62,
            0x06, 0x10, 0x61, 0x9D, 0xB4, 0x4B, 0x0C, 0xD4,
            0xFE, 0x0A, 0x47, 0xE0, 0x63, 0xC2, 0xD0, 0x9D,
            0x22, 0xF2, 0x13, 0xCF, 0xF0, 0x55, 0x5B, 0x5D,
            0x50
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 0, 0);
    };
    {
        /* Presig: Test vector 6 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char adaptor[33] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83
        };
        const unsigned char pre_sig[65] = {
            0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC,
            0x2F, 0x79, 0x78, 0x3A, 0xCC, 0xAA, 0x0E, 0x62,
            0x06, 0x10, 0x61, 0x9D, 0xB4, 0x4B, 0x0C, 0xD4,
            0xFE, 0x0A, 0x47, 0xE0, 0x63, 0xC2, 0xD0, 0x9D,
            0x22, 0xF2, 0x13, 0xCF, 0xF0, 0x55, 0x5B, 0x5D,
            0x50
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 0, 0);
    };
    {
        /* Presig: Test vector 7 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char adaptor[33] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83
        };
        const unsigned char pre_sig[65] = {
            0x04, 0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA,
            0x80, 0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A,
            0xD4, 0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D,
            0xA9, 0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60,
            0x13, 0x79, 0x78, 0x3A, 0xCC, 0xAA, 0x0E, 0x62,
            0x06, 0x10, 0x61, 0x9D, 0xB4, 0x4B, 0x0C, 0xD4,
            0xFE, 0x0A, 0x47, 0xE0, 0x63, 0xC2, 0xD0, 0x9D,
            0x22, 0xF2, 0x13, 0xCF, 0xF0, 0x55, 0x5B, 0x5D,
            0x50
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 0, 0);
    };
    {
        /* Presig: Test vector 8 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char adaptor[33] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83
        };
        const unsigned char pre_sig[65] = {
            0x02, 0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA,
            0x80, 0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A,
            0xD4, 0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D,
            0xA9, 0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60,
            0x13, 0x79, 0x78, 0x3A, 0xCC, 0xAA, 0x0E, 0x62,
            0x06, 0x10, 0x61, 0x9D, 0xB4, 0x4B, 0x0C, 0xD4,
            0xFE, 0x0A, 0x47, 0xE0, 0x63, 0xC2, 0xD0, 0x9D,
            0x22, 0xF2, 0x13, 0xCF, 0xF0, 0x55, 0x5B, 0x5D,
            0x50
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 1, 0);
    };
    {
        /* Presig: Test vector 9 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char adaptor[33] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83
        };
        const unsigned char pre_sig[65] = {
            0x03, 0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA,
            0x80, 0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A,
            0xD4, 0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D,
            0xA9, 0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60,
            0x13, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0,
            0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41,
            0x41
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 0, 0);
    };
    {
        /* Presig: Test vector 10 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char adaptor[33] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83
        };
        const unsigned char pre_sig[65] = {
            0x02, 0x70, 0x7A, 0x89, 0x22, 0xA7, 0xF9, 0x26,
            0x1A, 0x22, 0xA7, 0x05, 0x9E, 0x60, 0x35, 0x70,
            0x57, 0x2A, 0x71, 0x2A, 0x47, 0x53, 0xE3, 0x06,
            0xEE, 0xA5, 0xA6, 0x8B, 0x83, 0xC6, 0xC2, 0x48,
            0xA8, 0x8F, 0x77, 0x9F, 0xA0, 0x55, 0x99, 0x8A,
            0x02, 0x93, 0x8B, 0x38, 0x25, 0x5E, 0x37, 0x61,
            0x90, 0x17, 0x06, 0xFD, 0xDB, 0xF4, 0x77, 0x70,
            0x63, 0x87, 0xC0, 0x46, 0x0B, 0x6C, 0xFB, 0x89,
            0x2D
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 1, 0);
    };
    {
        /* Presig: Test vector 11 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char adaptor[33] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83
        };
        const unsigned char pre_sig[65] = {
            0x03, 0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA,
            0x80, 0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A,
            0xD4, 0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D,
            0xA9, 0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60,
            0x13, 0x86, 0x87, 0xC5, 0x33, 0x55, 0xF1, 0x9D,
            0xF9, 0xEF, 0x9E, 0x62, 0x4B, 0xB4, 0xF3, 0x2B,
            0x00, 0xB0, 0x66, 0xFC, 0x82, 0xEC, 0x78, 0x03,
            0x18, 0xCD, 0xBE, 0x8E, 0x9C, 0x7A, 0xDA, 0xE3,
            0xF1
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 1, 0);
    };
    {
        /* Presig: Test vector 12 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char adaptor[33] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83
        };
        const unsigned char pre_sig[65] = {
            0x02, 0x67, 0x8F, 0x02, 0xC8, 0x63, 0xB8, 0x2C,
            0xB7, 0xB6, 0xF0, 0xE5, 0x21, 0x60, 0x6A, 0xD8,
            0xDC, 0x75, 0xC1, 0xAC, 0x71, 0xD9, 0x74, 0x53,
            0xDB, 0x1A, 0x15, 0x61, 0x0E, 0x15, 0xA1, 0x2C,
            0x83, 0x92, 0x62, 0xEC, 0xE4, 0xF1, 0x76, 0xC3,
            0xDE, 0x64, 0x2D, 0xDD, 0x09, 0xE8, 0xF5, 0xBF,
            0xB1, 0xB0, 0x84, 0xFA, 0x17, 0x78, 0x76, 0x41,
            0xB1, 0xD8, 0x76, 0x1E, 0x3C, 0xE9, 0x7E, 0xE0,
            0xA2
        };
        test_schnorr_adaptor_spec_vectors_check_extract(pk, msg, adaptor, pre_sig, 0, 0);
    };
    {
        /* Presig: Test vector 13 & 14 */
        const unsigned char adaptor[33] = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00
        };
        secp256k1_pubkey adaptor_parsed;
        /* No need to check adaptor_extract as parsing the adaptor point already fails */
        CHECK(!secp256k1_ec_pubkey_parse(CTX, &adaptor_parsed, adaptor, sizeof(adaptor)));
    };
    {
        /* Adapt: Test vector 0 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char sec_adaptor[32] = {
            0x84, 0x8B, 0xC8, 0x7F, 0x32, 0xC6, 0xF7, 0x1D,
            0x3A, 0x93, 0xA5, 0x94, 0x24, 0x58, 0x45, 0x62,
            0x04, 0x6F, 0x31, 0x69, 0x37, 0x16, 0xFF, 0x73,
            0xA8, 0x97, 0xCC, 0xC1, 0x65, 0x9C, 0x5F, 0x5D
        };
        const unsigned char pre_sig[65] = {
            0x02, 0x70, 0x7A, 0x89, 0x22, 0xA7, 0xF9, 0x26,
            0x1A, 0x22, 0xA7, 0x05, 0x9E, 0x60, 0x35, 0x70,
            0x57, 0x2A, 0x71, 0x2A, 0x47, 0x53, 0xE3, 0x06,
            0xEE, 0xA5, 0xA6, 0x8B, 0x83, 0xC6, 0xC2, 0x48,
            0xA8, 0x8F, 0x77, 0x9F, 0xA0, 0x55, 0x99, 0x8A,
            0x02, 0x93, 0x8B, 0x38, 0x25, 0x5E, 0x37, 0x61,
            0x90, 0x17, 0x06, 0xFD, 0xDB, 0xF4, 0x77, 0x70,
            0x63, 0x87, 0xC0, 0x46, 0x0B, 0x6C, 0xFB, 0x89,
            0x2D
        };
        const unsigned char sig[64] = {
            0x70, 0x7A, 0x89, 0x22, 0xA7, 0xF9, 0x26, 0x1A,
            0x22, 0xA7, 0x05, 0x9E, 0x60, 0x35, 0x70, 0x57,
            0x2A, 0x71, 0x2A, 0x47, 0x53, 0xE3, 0x06, 0xEE,
            0xA5, 0xA6, 0x8B, 0x83, 0xC6, 0xC2, 0x48, 0xA8,
            0x14, 0x03, 0x68, 0x1F, 0x88, 0x60, 0x81, 0x1F,
            0xCE, 0x1E, 0xDD, 0xB9, 0x82, 0x8F, 0xA6, 0xF3,
            0x60, 0xC7, 0x52, 0x5E, 0x7C, 0x45, 0xCF, 0x9B,
            0x70, 0x85, 0xB4, 0x40, 0x02, 0x61, 0xA7, 0x49
        };
        test_schnorr_adaptor_spec_vectors_check_adapt(pk, msg, pre_sig, sec_adaptor, sig, 0);
    };
    {
        /* Adapt: Test vector 1 */
        const unsigned char pk[32] = {
            0xA1, 0x8D, 0xBC, 0x8D, 0xBF, 0x16, 0x3C, 0x60,
            0xDF, 0xA2, 0xEC, 0x7C, 0x87, 0xAC, 0x11, 0x3C,
            0xA4, 0x82, 0xFA, 0x2E, 0x1F, 0xDD, 0xD3, 0xEC,
            0x84, 0x21, 0xBF, 0x9B, 0xFA, 0x2E, 0xF1, 0xF2
        };
        const unsigned char msg[32] = {
            0x38, 0x95, 0x75, 0xB9, 0x2B, 0x58, 0x6B, 0xE2,
            0x73, 0x0A, 0x99, 0x82, 0x41, 0xE5, 0xCF, 0x65,
            0x1D, 0x6C, 0x19, 0x1F, 0xA6, 0x4E, 0xEA, 0x3D,
            0x00, 0x25, 0x6A, 0xFF, 0x7D, 0x18, 0x48, 0x4F
        };
        const unsigned char sec_adaptor[32] = {
            0xE5, 0xE6, 0x8D, 0x0E, 0x63, 0x7D, 0xA4, 0x82,
            0x27, 0x32, 0xE2, 0x0F, 0x3E, 0xEB, 0xE1, 0x82,
            0x68, 0x92, 0xE8, 0x1C, 0x2C, 0xFE, 0xC6, 0xBE,
            0xC6, 0x00, 0xCD, 0xA3, 0xF6, 0x6A, 0x53, 0xF1
        };
        const unsigned char pre_sig[65] = {
            0x03, 0x73, 0xDB, 0x6D, 0x58, 0x03, 0xED, 0xD6,
            0x50, 0x2D, 0xE3, 0xD0, 0x95, 0x6B, 0xA3, 0xBD,
            0x3F, 0xAB, 0xA9, 0x88, 0x41, 0xC9, 0xAB, 0x07,
            0x4C, 0x79, 0x5E, 0x3A, 0x90, 0x12, 0xC4, 0x29,
            0x8A, 0x4B, 0x6C, 0x99, 0xEE, 0x31, 0xDB, 0x1C,
            0x15, 0x81, 0x30, 0x28, 0x26, 0x2E, 0xC2, 0x5E,
            0x0E, 0x04, 0xC9, 0xD3, 0x04, 0x15, 0x55, 0x85,
            0xF8, 0x5E, 0xC0, 0x02, 0x42, 0x2D, 0x20, 0x5D,
            0x6E
        };
        const unsigned char sig[64] = {
            0x73, 0xDB, 0x6D, 0x58, 0x03, 0xED, 0xD6, 0x50,
            0x2D, 0xE3, 0xD0, 0x95, 0x6B, 0xA3, 0xBD, 0x3F,
            0xAB, 0xA9, 0x88, 0x41, 0xC9, 0xAB, 0x07, 0x4C,
            0x79, 0x5E, 0x3A, 0x90, 0x12, 0xC4, 0x29, 0x8A,
            0x65, 0x86, 0x0C, 0xDF, 0xCE, 0x5D, 0x77, 0x93,
            0x59, 0xFD, 0x46, 0x16, 0xEF, 0xD6, 0x7C, 0x8A,
            0x56, 0xE5, 0xC7, 0xCE, 0x97, 0x9F, 0x5F, 0x75,
            0x58, 0x91, 0x93, 0x2B, 0x06, 0xEC, 0x4A, 0xBE
        };
        test_schnorr_adaptor_spec_vectors_check_adapt(pk, msg, pre_sig, sec_adaptor, sig, 1);
    };
    {
        /* Adapt: Test vector 2 */
        const unsigned char pk[32] = {
            0x15, 0xBF, 0x35, 0x43, 0x75, 0xCF, 0xBE, 0xDB,
            0x43, 0xDA, 0xC7, 0xD6, 0x6B, 0xCA, 0x46, 0xF5,
            0xCF, 0x0A, 0x42, 0xFF, 0xF0, 0x60, 0xEC, 0x0C,
            0xCC, 0x59, 0xA3, 0x96, 0xB2, 0x25, 0x43, 0x85
        };
        const unsigned char msg[32] = {
            0x2F, 0x4E, 0x50, 0x5E, 0x2C, 0x70, 0xE8, 0x1B,
            0x94, 0x43, 0x18, 0x00, 0xF8, 0x10, 0xEC, 0xB0,
            0x4F, 0xD0, 0xAA, 0xEE, 0xB0, 0xC7, 0x03, 0xF8,
            0xDC, 0xE4, 0x4E, 0xED, 0xFA, 0x0A, 0xB8, 0xC2
        };
        const unsigned char sec_adaptor[32] = {
            0x53, 0x92, 0x12, 0xA1, 0xB9, 0xFC, 0x42, 0xF4,
            0x4A, 0xD1, 0xA5, 0x77, 0x20, 0xC7, 0x44, 0x40,
            0x84, 0x03, 0xFF, 0xFF, 0x80, 0x58, 0x48, 0x66,
            0x40, 0x27, 0xFC, 0x9C, 0x74, 0xB3, 0x87, 0x6A
        };
        const unsigned char pre_sig[65] = {
            0x02, 0xE4, 0xC4, 0x16, 0x13, 0x45, 0xD8, 0xC9,
            0xD8, 0x4A, 0x50, 0xD5, 0x76, 0x25, 0x76, 0xBE,
            0x7B, 0xCF, 0x1E, 0xA3, 0x13, 0x21, 0xBA, 0x6A,
            0x6F, 0x3C, 0x64, 0x18, 0x53, 0x6D, 0xB4, 0x3D,
            0xB4, 0x96, 0x72, 0x85, 0x58, 0xD7, 0x79, 0x65,
            0xA6, 0x42, 0x6D, 0x5C, 0x6A, 0x25, 0xB3, 0xF0,
            0xB0, 0x2E, 0xCE, 0xC4, 0x9F, 0xBB, 0xC7, 0xC9,
            0x66, 0xB9, 0xE3, 0x87, 0x6C, 0x33, 0x70, 0x4C,
            0xB5
        };
        const unsigned char sig[64] = {
            0xE4, 0xC4, 0x16, 0x13, 0x45, 0xD8, 0xC9, 0xD8,
            0x4A, 0x50, 0xD5, 0x76, 0x25, 0x76, 0xBE, 0x7B,
            0xCF, 0x1E, 0xA3, 0x13, 0x21, 0xBA, 0x6A, 0x6F,
            0x3C, 0x64, 0x18, 0x53, 0x6D, 0xB4, 0x3D, 0xB4,
            0xEA, 0x04, 0x97, 0xFA, 0x91, 0x75, 0xA8, 0x9A,
            0x8D, 0x3F, 0x01, 0xE1, 0x46, 0x7B, 0x34, 0xF0,
            0xB2, 0xD2, 0xC4, 0x9F, 0x3C, 0x20, 0x11, 0xCC,
            0xFA, 0x0B, 0x84, 0x08, 0xA8, 0x23, 0xD4, 0x1F
        };
        test_schnorr_adaptor_spec_vectors_check_adapt(pk, msg, pre_sig, sec_adaptor, sig, 1);
    };
    {
        /* Adapt: Test vector 3 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char sec_adaptor[32] = {
            0x84, 0x8B, 0xC8, 0x7F, 0x32, 0xC6, 0xF7, 0x1D,
            0x3A, 0x93, 0xA5, 0x94, 0x24, 0x58, 0x45, 0x62,
            0x04, 0x6F, 0x31, 0x69, 0x37, 0x16, 0xFF, 0x73,
            0xA8, 0x97, 0xCC, 0xC1, 0x65, 0x9C, 0x5F, 0x5D
        };
        const unsigned char pre_sig[65] = {
            0x03, 0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA,
            0x80, 0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A,
            0xD4, 0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D,
            0xA9, 0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60,
            0x13, 0x86, 0x87, 0xC5, 0x33, 0x55, 0xF1, 0x9D,
            0xF9, 0xEF, 0x9E, 0x62, 0x4B, 0xB4, 0xF3, 0x2B,
            0x00, 0xB0, 0x66, 0xFC, 0x82, 0xEC, 0x78, 0x03,
            0x18, 0xCD, 0xBE, 0x8E, 0x9C, 0x7A, 0xDA, 0xE3,
            0xF1
        };
        const unsigned char sig[64] = {
            0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA, 0x80,
            0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A, 0xD4,
            0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D, 0xA9,
            0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60, 0x13,
            0x01, 0xFB, 0xFC, 0xB4, 0x23, 0x2A, 0xA6, 0xDC,
            0xB5, 0x0A, 0xBC, 0xB7, 0x90, 0x9A, 0xE5, 0x9E,
            0xAB, 0xF7, 0xCB, 0x19, 0xB5, 0x61, 0x03, 0xA5,
            0x25, 0x26, 0xC1, 0xDB, 0x15, 0x3E, 0x84, 0x94
        };
        test_schnorr_adaptor_spec_vectors_check_adapt(pk, msg, pre_sig, sec_adaptor, sig, 0);
    };
    {
        /* Adapt: Test vector 4 */
        const unsigned char pk[32] = {
            0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F,
            0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE,
            0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8,
            0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59
        };
        const unsigned char msg[32] = {
            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,
            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,
            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,
            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89
        };
        const unsigned char sec_adaptor[32] = {
            0x84, 0x8B, 0xC8, 0x7F, 0x32, 0xC6, 0xF7, 0x1D,
            0x3A, 0x93, 0xA5, 0x94, 0x24, 0x58, 0x45, 0x62,
            0x04, 0x6F, 0x31, 0x69, 0x37, 0x16, 0xFF, 0x73,
            0xA8, 0x97, 0xCC, 0xC1, 0x65, 0x9C, 0x5F, 0x5D
        };
        const unsigned char pre_sig[65] = {
            0x02, 0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA,
            0x80, 0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A,
            0xD4, 0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D,
            0xA9, 0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60,
            0x13, 0x79, 0x78, 0x3A, 0xCC, 0xAA, 0x0E, 0x62,
            0x06, 0x10, 0x61, 0x9D, 0xB4, 0x4B, 0x0C, 0xD4,
            0xFE, 0x0A, 0x47, 0xE0, 0x63, 0xC2, 0xD0, 0x9D,
            0x22, 0xF2, 0x13, 0xCF, 0xF0, 0x55, 0x5B, 0x5D,
            0x50
        };
        const unsigned char sig[64] = {
            0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA, 0x80,
            0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A, 0xD4,
            0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D, 0xA9,
            0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60, 0x13,
            0xFE, 0x04, 0x03, 0x4B, 0xDC, 0xD5, 0x59, 0x23,
            0x4A, 0xF5, 0x43, 0x48, 0x6F, 0x65, 0x1A, 0x60,
            0x0E, 0xB7, 0x11, 0xCC, 0xF9, 0xE7, 0x9C, 0x96,
            0x9A, 0xAB, 0x9C, 0xB1, 0xBA, 0xF7, 0xBC, 0xAD
        };
        test_schnorr_adaptor_spec_vectors_check_adapt(pk, msg, pre_sig, sec_adaptor, sig, 0);
    };
    {
        /* Secadapt: Test vector 0 */
        const unsigned char pre_sig[65] = {
            0x03, 0x73, 0xDB, 0x6D, 0x58, 0x03, 0xED, 0xD6,
            0x50, 0x2D, 0xE3, 0xD0, 0x95, 0x6B, 0xA3, 0xBD,
            0x3F, 0xAB, 0xA9, 0x88, 0x41, 0xC9, 0xAB, 0x07,
            0x4C, 0x79, 0x5E, 0x3A, 0x90, 0x12, 0xC4, 0x29,
            0x8A, 0x4B, 0x6C, 0x99, 0xEE, 0x31, 0xDB, 0x1C,
            0x15, 0x81, 0x30, 0x28, 0x26, 0x2E, 0xC2, 0x5E,
            0x0E, 0x04, 0xC9, 0xD3, 0x04, 0x15, 0x55, 0x85,
            0xF8, 0x5E, 0xC0, 0x02, 0x42, 0x2D, 0x20, 0x5D,
            0x6E
        };
        const unsigned char sig[64] = {
            0x73, 0xDB, 0x6D, 0x58, 0x03, 0xED, 0xD6, 0x50,
            0x2D, 0xE3, 0xD0, 0x95, 0x6B, 0xA3, 0xBD, 0x3F,
            0xAB, 0xA9, 0x88, 0x41, 0xC9, 0xAB, 0x07, 0x4C,
            0x79, 0x5E, 0x3A, 0x90, 0x12, 0xC4, 0x29, 0x8A,
            0x65, 0x86, 0x0C, 0xDF, 0xCE, 0x5D, 0x77, 0x93,
            0x59, 0xFD, 0x46, 0x16, 0xEF, 0xD6, 0x7C, 0x8A,
            0x56, 0xE5, 0xC7, 0xCE, 0x97, 0x9F, 0x5F, 0x75,
            0x58, 0x91, 0x93, 0x2B, 0x06, 0xEC, 0x4A, 0xBE
        };
        const unsigned char sec_adaptor[32] = {
            0xE5, 0xE6, 0x8D, 0x0E, 0x63, 0x7D, 0xA4, 0x82,
            0x27, 0x32, 0xE2, 0x0F, 0x3E, 0xEB, 0xE1, 0x82,
            0x68, 0x92, 0xE8, 0x1C, 0x2C, 0xFE, 0xC6, 0xBE,
            0xC6, 0x00, 0xCD, 0xA3, 0xF6, 0x6A, 0x53, 0xF1
        };
        test_schnorr_adaptor_spec_vectors_check_extract_sec(pre_sig, sig, sec_adaptor, 1);
    };
    {
        /* Secadapt: Test vector 1 */
        const unsigned char pre_sig[65] = {
            0x02, 0xE4, 0xC4, 0x16, 0x13, 0x45, 0xD8, 0xC9,
            0xD8, 0x4A, 0x50, 0xD5, 0x76, 0x25, 0x76, 0xBE,
            0x7B, 0xCF, 0x1E, 0xA3, 0x13, 0x21, 0xBA, 0x6A,
            0x6F, 0x3C, 0x64, 0x18, 0x53, 0x6D, 0xB4, 0x3D,
            0xB4, 0x96, 0x72, 0x85, 0x58, 0xD7, 0x79, 0x65,
            0xA6, 0x42, 0x6D, 0x5C, 0x6A, 0x25, 0xB3, 0xF0,
            0xB0, 0x2E, 0xCE, 0xC4, 0x9F, 0xBB, 0xC7, 0xC9,
            0x66, 0xB9, 0xE3, 0x87, 0x6C, 0x33, 0x70, 0x4C,
            0xB5
        };
        const unsigned char sig[64] = {
            0xE4, 0xC4, 0x16, 0x13, 0x45, 0xD8, 0xC9, 0xD8,
            0x4A, 0x50, 0xD5, 0x76, 0x25, 0x76, 0xBE, 0x7B,
            0xCF, 0x1E, 0xA3, 0x13, 0x21, 0xBA, 0x6A, 0x6F,
            0x3C, 0x64, 0x18, 0x53, 0x6D, 0xB4, 0x3D, 0xB4,
            0xEA, 0x04, 0x97, 0xFA, 0x91, 0x75, 0xA8, 0x9A,
            0x8D, 0x3F, 0x01, 0xE1, 0x46, 0x7B, 0x34, 0xF0,
            0xB2, 0xD2, 0xC4, 0x9F, 0x3C, 0x20, 0x11, 0xCC,
            0xFA, 0x0B, 0x84, 0x08, 0xA8, 0x23, 0xD4, 0x1F
        };
        const unsigned char sec_adaptor[32] = {
            0x53, 0x92, 0x12, 0xA1, 0xB9, 0xFC, 0x42, 0xF4,
            0x4A, 0xD1, 0xA5, 0x77, 0x20, 0xC7, 0x44, 0x40,
            0x84, 0x03, 0xFF, 0xFF, 0x80, 0x58, 0x48, 0x66,
            0x40, 0x27, 0xFC, 0x9C, 0x74, 0xB3, 0x87, 0x6A
        };
        test_schnorr_adaptor_spec_vectors_check_extract_sec(pre_sig, sig, sec_adaptor, 1);
    };
    {
        /* Secadapt: Test vector 2 */
        const unsigned char pre_sig[65] = {
            0x03, 0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA,
            0x80, 0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A,
            0xD4, 0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D,
            0xA9, 0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60,
            0x13, 0x79, 0x78, 0x3A, 0xCC, 0xAA, 0x0E, 0x62,
            0x06, 0x10, 0x61, 0x9D, 0xB4, 0x4B, 0x0C, 0xD4,
            0xFE, 0x0A, 0x47, 0xE0, 0x63, 0xC2, 0xD0, 0x9D,
            0x22, 0xF2, 0x13, 0xCF, 0xF0, 0x55, 0x5B, 0x5D,
            0x50
        };
        const unsigned char sig[64] = {
            0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA, 0x80,
            0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A, 0xD4,
            0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D, 0xA9,
            0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60, 0x13,
            0x01, 0xFB, 0xFC, 0xB4, 0x23, 0x2A, 0xA6, 0xDC,
            0xB5, 0x0A, 0xBC, 0xB7, 0x90, 0x9A, 0xE5, 0x9E,
            0xAB, 0xF7, 0xCB, 0x19, 0xB5, 0x61, 0x03, 0xA5,
            0x25, 0x26, 0xC1, 0xDB, 0x15, 0x3E, 0x84, 0x94
        };
        const unsigned char sec_adaptor[32] = {
            0x84, 0x8B, 0xC8, 0x7F, 0x32, 0xC6, 0xF7, 0x1D,
            0x3A, 0x93, 0xA5, 0x94, 0x24, 0x58, 0x45, 0x62,
            0x04, 0x6F, 0x31, 0x69, 0x37, 0x16, 0xFF, 0x73,
            0xA8, 0x97, 0xCC, 0xC1, 0x65, 0x9C, 0x5F, 0x5D
        };
        test_schnorr_adaptor_spec_vectors_check_extract_sec(pre_sig, sig, sec_adaptor, 0);
    };
    {
        /* Secadapt: Test vector 3 */
        const unsigned char pre_sig[65] = {
            0x03, 0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA,
            0x80, 0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A,
            0xD4, 0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D,
            0xA9, 0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60,
            0x13, 0x79, 0x78, 0x3A, 0xCC, 0xAA, 0x0E, 0x62,
            0x06, 0x10, 0x61, 0x9D, 0xB4, 0x4B, 0x0C, 0xD4,
            0xFE, 0x0A, 0x47, 0xE0, 0x63, 0xC2, 0xD0, 0x9D,
            0x22, 0xF2, 0x13, 0xCF, 0xF0, 0x55, 0x5B, 0x5D,
            0x50
        };
        const unsigned char sig[64] = {
            0xB8, 0x61, 0x3C, 0xCA, 0x78, 0xF4, 0xFA, 0x80,
            0xEA, 0x58, 0xEE, 0xD0, 0xC2, 0x6B, 0x4A, 0xD4,
            0x91, 0xEF, 0xFC, 0x44, 0x50, 0x3C, 0x8D, 0xA9,
            0x0D, 0x15, 0xA9, 0xC1, 0x7E, 0xD2, 0x60, 0x13,
            0xFE, 0x04, 0x03, 0x4B, 0xDC, 0xD5, 0x59, 0x23,
            0x4A, 0xF5, 0x43, 0x48, 0x6F, 0x65, 0x1A, 0x60,
            0x0E, 0xB7, 0x11, 0xCC, 0xF9, 0xE7, 0x9C, 0x96,
            0x9A, 0xAB, 0x9C, 0xB1, 0xBA, 0xF7, 0xBC, 0xAD
        };
        const unsigned char sec_adaptor[32] = {
            0x84, 0x8B, 0xC8, 0x7F, 0x32, 0xC6, 0xF7, 0x1D,
            0x3A, 0x93, 0xA5, 0x94, 0x24, 0x58, 0x45, 0x62,
            0x04, 0x6F, 0x31, 0x69, 0x37, 0x16, 0xFF, 0x73,
            0xA8, 0x97, 0xCC, 0xC1, 0x65, 0x9C, 0x5F, 0x5D
        };
        test_schnorr_adaptor_spec_vectors_check_extract_sec(pre_sig, sig, sec_adaptor, 0);
    };
}

static void test_schnorr_adaptor_edge_cases(void) {
    unsigned char sk[32];
    secp256k1_xonly_pubkey pk;
    secp256k1_keypair keypair;
    const unsigned char msg[32] = "this is a schnorr adaptor msg...";
    unsigned char sec_adaptor[32];
    unsigned char extracted_sec_adaptor[32];
    secp256k1_pubkey adaptor;
    secp256k1_pubkey extracted_adaptor;
    unsigned char aux_rand[32];
    unsigned char pre_sig[65];
    unsigned char sig[64];

    secp256k1_testrand256(sk);
    secp256k1_testrand256(sec_adaptor);
    secp256k1_testrand256(aux_rand);
    CHECK(secp256k1_keypair_create(CTX, &keypair, sk));
    CHECK(secp256k1_keypair_xonly_pub(CTX, &pk, NULL, &keypair));
    CHECK(secp256k1_ec_pubkey_create(CTX, &adaptor, sec_adaptor));

    /* Test schnorr_adaptor_presign */
    CHECK(secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &keypair, &adaptor, aux_rand) == 1);

    /* TODO: test with different nonce functions after `schnorr_adaptor_presign_custom`
     * gets implemented */

    /* Test schnorr_adaptor_extract */
    CHECK(secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &keypair, &adaptor, aux_rand) == 1);
    CHECK(secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor, pre_sig, msg, &pk) == 1);
    CHECK(secp256k1_ec_pubkey_cmp(CTX, &extracted_adaptor, &adaptor) == 0);
    {
        /* invalid R' (= pre_sig[0:33]) */
        unsigned char pre_sig_tmp[65];
        secp256k1_pubkey extracted_adaptor_tmp;
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        memset(pre_sig_tmp, 0xFF, 33);
        CHECK(secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor_tmp, pre_sig_tmp, msg, &pk) == 0);
    }
    {
        /* overflowing s */
        unsigned char pre_sig_tmp[65];
        secp256k1_pubkey extracted_adaptor_tmp;
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        memset(&pre_sig_tmp[33], 0xFF, 32);
        CHECK(secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor_tmp, pre_sig_tmp, msg, &pk) == 0);
    }
    {
        /* negated s */
        unsigned char pre_sig_tmp[65];
        secp256k1_scalar s;
        secp256k1_pubkey extracted_adaptor_tmp;
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        secp256k1_scalar_set_b32(&s, &pre_sig_tmp[33], NULL);
        secp256k1_scalar_negate(&s, &s);
        secp256k1_scalar_get_b32(&pre_sig_tmp[33], &s);
        CHECK(secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor_tmp, pre_sig_tmp, msg, &pk) == 1);
        CHECK(secp256k1_ec_pubkey_cmp(CTX, &extracted_adaptor_tmp, &adaptor) != 0);
    }
    {
        /* any flipped bit in the pre-signature will extract
         * an invalid adaptor point */
        unsigned char pre_sig_tmp[65];
        secp256k1_pubkey extracted_adaptor_tmp;
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        rand_flip_bit(&pre_sig_tmp[1], sizeof(pre_sig_tmp) - 1);
        /* depending on which bit was flipped adaptor_extract can either
         * return 0 (parsing pre-signature failed) or 1 (parsing
         * pre-signature success) */
        if(secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor_tmp, pre_sig_tmp, msg, &pk)) {
            CHECK(secp256k1_ec_pubkey_cmp(CTX, &extracted_adaptor_tmp, &adaptor) != 0);
        }
    }
    {
        /* any flipped bit in the message will extract an invalid
         * adaptor point */
        unsigned char msg_tmp[32];
        secp256k1_pubkey extracted_adaptor_tmp;
        memcpy(msg_tmp, msg, sizeof(msg_tmp));
        rand_flip_bit(msg_tmp, sizeof(msg_tmp));
        CHECK(secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor_tmp, pre_sig, msg_tmp, &pk) == 1);
        CHECK(secp256k1_ec_pubkey_cmp(CTX, &extracted_adaptor_tmp, &adaptor) != 0);
    }
    /* Note: presig test vectors 12, 13, 14 will cover the case where
     * adaptor_extract returns 0 when [1] R = infinity, or [2] T = infinity.
     * So, we don't need to test those scenarios here */

    /* Test schnorr_adaptor_adapt */
    CHECK(secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &keypair, &adaptor, aux_rand) == 1);
    CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig, pre_sig, sec_adaptor) == 1);
    CHECK(secp256k1_schnorrsig_verify(CTX, sig, msg, sizeof(msg), &pk) == 1);
    {
        /* overflowing sec_adaptor */
        unsigned char sig_tmp[64];
        unsigned char sec_adaptor_tmp[32];
        memset(sec_adaptor_tmp, 0xFF, 32);
        CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig_tmp, pre_sig, sec_adaptor_tmp) == 0);
    }
    {
        /* overflowing s */
        unsigned char sig_tmp[64];
        unsigned char pre_sig_tmp[65];
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        memset(&pre_sig_tmp[33], 0xFF, 32);
        CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig_tmp, pre_sig_tmp, sec_adaptor) == 0);
    }
    {
        /* negated s */
        unsigned char sig_tmp[64];
        unsigned char pre_sig_tmp[65];
        secp256k1_scalar s;
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        secp256k1_scalar_set_b32(&s, &pre_sig_tmp[33], NULL);
        secp256k1_scalar_negate(&s, &s);
        secp256k1_scalar_get_b32(&pre_sig_tmp[33], &s);
        CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig_tmp, pre_sig_tmp, sec_adaptor) == 1);
        CHECK(secp256k1_schnorrsig_verify(CTX, sig_tmp, msg, sizeof(msg), &pk) == 0);
    }
    {
        /* any flipped bit in the pre-signature will result in
         * an invalid signature */
        unsigned char sig_tmp[64];
        unsigned char pre_sig_tmp[65];
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        rand_flip_bit(&pre_sig_tmp[1], sizeof(pre_sig_tmp) - 1);
        /* depending on which bit was flipped adaptor_adapt can either
         * return 0 (parsing pre_sig_tmp[33:65] failed) or 1 (parsing
         * success but invalid sig will be generated) */
        if (secp256k1_schnorr_adaptor_adapt(CTX, sig_tmp, pre_sig_tmp, sec_adaptor)) {
            CHECK(secp256k1_schnorrsig_verify(CTX, sig_tmp, msg, sizeof(msg), &pk) == 0);
        }
    }
    {
        /* any flipped bit in the sec_adaptor will result in an
         * invalid signature */
        unsigned char sig_tmp[64];
        unsigned char sec_adaptor_tmp[32];
        memcpy(sec_adaptor_tmp, sec_adaptor, sizeof(sec_adaptor_tmp));
        rand_flip_bit(sec_adaptor_tmp, sizeof(sec_adaptor_tmp));
        CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig_tmp, pre_sig, sec_adaptor_tmp) == 1);
        CHECK(secp256k1_schnorrsig_verify(CTX, sig_tmp, msg, sizeof(msg), &pk) == 0);
    }

    /* Test schnorr_adaptor_extract_sec */
    CHECK(secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &keypair, &adaptor, aux_rand) == 1);
    CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig, pre_sig, sec_adaptor) == 1);
    CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor, pre_sig, sig) == 1);
    CHECK(secp256k1_memcmp_var(extracted_sec_adaptor, sec_adaptor, sizeof(extracted_sec_adaptor)) == 0);
    {
        /* overflowing pre_sig[33:65] */
        unsigned char extracted_sec_adaptor_tmp[32];
        unsigned char pre_sig_tmp[65];
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        memset(&pre_sig_tmp[33], 0xFF, 32);
        CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor_tmp, pre_sig_tmp, sig) == 0);
    }
    {
        /* overflowing sig[32:64] */
        unsigned char extracted_sec_adaptor_tmp[32];
        unsigned char sig_tmp[64];
        memcpy(sig_tmp, sig, sizeof(sig_tmp));
        memset(&sig_tmp[32], 0xFF, 32);
        CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor_tmp, pre_sig, sig_tmp) == 0);
    }
    {
        /* any flipped bit in pre_sig[33:65] will extract
         * an invalid secret adaptor */
        unsigned char extracted_sec_adaptor_tmp[32];
        unsigned char pre_sig_tmp[65];
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        rand_flip_bit(&pre_sig_tmp[33], sizeof(pre_sig_tmp) - 33);
        CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor_tmp, pre_sig_tmp, sig) == 1);
        CHECK(secp256k1_memcmp_var(extracted_sec_adaptor_tmp, sec_adaptor, sizeof(extracted_sec_adaptor_tmp)) != 0);
    }
    {
        /* any flipped bit in sig[32:64] will extract
         * an invalid secret adaptor */
        unsigned char extracted_sec_adaptor_tmp[32];
        unsigned char sig_tmp[64];
        memcpy(sig_tmp, sig, sizeof(sig_tmp));
        rand_flip_bit(&sig_tmp[32], sizeof(sig_tmp) - 32);
        CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor_tmp, pre_sig, sig_tmp) == 1);
        CHECK(secp256k1_memcmp_var(extracted_sec_adaptor_tmp, sec_adaptor, sizeof(extracted_sec_adaptor_tmp)) != 0);
    }
    {
        /* invalid presig[0:33] or sig[0:32] does not
         * neccessarily result in an invalid output */
        unsigned char extracted_sec_adaptor_tmp[32];
        unsigned char pre_sig_tmp[65];
        unsigned char sig_tmp[64];
        memcpy(pre_sig_tmp, pre_sig, sizeof(pre_sig_tmp));
        memcpy(sig_tmp, sig, sizeof(sig_tmp));
        memset(&pre_sig_tmp[1], 0xFF, 32);
        memset(sig_tmp, 0xFF, 32);
        CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor_tmp, pre_sig_tmp, sig_tmp) == 1);
        CHECK(secp256k1_memcmp_var(extracted_sec_adaptor_tmp, sec_adaptor, sizeof(extracted_sec_adaptor_tmp)) == 0);
    }
}

static void test_schnorr_adaptor_correctness(void) {
    unsigned char alice_sk[32];
    secp256k1_keypair alice_keypair;
    secp256k1_xonly_pubkey alice_pk;
    unsigned char sec_adaptor[32];
    secp256k1_pubkey adaptor;
    unsigned char extracted_sec_adaptor[32];
    secp256k1_pubkey extracted_adaptor;
    unsigned char msg[32];
    unsigned char pre_sig[65];
    unsigned char sig[64];

    /* Alice setup */
    secp256k1_testrand256(alice_sk);
    CHECK(secp256k1_keypair_create(CTX, &alice_keypair, alice_sk) == 1);
    CHECK(secp256k1_keypair_xonly_pub(CTX, &alice_pk, NULL, &alice_keypair) == 1);

    /* t := sec_adaptor
     * There exists an adaptor T = t*G, where t is unknown to Bob */
    secp256k1_testrand256(sec_adaptor);
    CHECK(secp256k1_ec_pubkey_create(CTX, &adaptor, sec_adaptor));

    /* Alice creates a pre-siganture for the adaptor point T,
     * and sends it to Bob. */
    secp256k1_testrand256(msg);
    CHECK(secp256k1_schnorr_adaptor_presign(CTX, pre_sig, msg, &alice_keypair, &adaptor, NULL) == 1);

    /* Bob extracts the adaptor point from the pre-signature,
     * and verifies if it is equal to T */
    CHECK(secp256k1_schnorr_adaptor_extract(CTX, &extracted_adaptor, pre_sig, msg, &alice_pk) == 1);
    CHECK(secp256k1_ec_pubkey_cmp(CTX, &extracted_adaptor, &adaptor) == 0);

    /* Bob learns t (the discrete logarithm of T). For example, Bob can
     * pay a Lightning invoice that reveals t, assuming Lightning uses
     * PTLC (Point Time Locked Contracts). */

    /* Bob adapts the pre-signature with the discrete logarithm of T to
     * create a valid BIP 340 Schnorr signature. */
    CHECK(secp256k1_schnorr_adaptor_adapt(CTX, sig, pre_sig, sec_adaptor) == 1);
    CHECK(secp256k1_schnorrsig_verify(CTX, sig, msg, sizeof(msg), &alice_pk) == 1);

    /* Alice learns the BIP340 signature after Bob publishes it on the blockchain. */

    /* Alice extracts the discrete logarithm of T from the pre-signature and the
     * BIP 340 signature. */
    CHECK(secp256k1_schnorr_adaptor_extract_sec(CTX, extracted_sec_adaptor, pre_sig, sig) == 1);
    CHECK(secp256k1_memcmp_var(extracted_sec_adaptor, sec_adaptor, sizeof(extracted_sec_adaptor)) == 0);
}

static void run_schnorr_adaptor_tests(void) {
    int i;
    run_nonce_function_schnorr_adaptor_tests();

    test_schnorr_adaptor_api();
    test_schnorr_adaptor_spec_vectors();
    for (i = 0; i < COUNT; i++) {
        test_schnorr_adaptor_edge_cases();
    }
    test_schnorr_adaptor_correctness();
}

#endif
